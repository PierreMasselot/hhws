% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find.threshold.R
\name{predict_alarms}
\alias{predict_alarms}
\title{Predict alarms}
\usage{
predict_alarms(indicators, alpha, s, y = NA, r = 1)
}
\arguments{
\item{indicators}{List of matrices containing values of the lagged covariates
to test whether they are alarms. Can also be a matrix in the case of a
single indicator.}

\item{alpha}{List of vectors giving the weightings used to construct 
indicators. Must have the same length as \code{indicators} and each 
vector must have the same length as \code{ncol} of each matric in 
\code{indicators}.}

\item{s}{Vector of thresholds. Must have the same length as 
\code{indicators}.}

\item{y}{Optional vector of corresponding response value. Must have the same
length as the number of rows of each matrix in \code{indicators}.}

\item{r}{Positive integer. Number of consecutive values below threshold
following an alarm to end the episode.}
}
\value{
A data.frame object containing the indices, episode number, and the 
   values of both the response and indicators for all alarms found.
}
\description{
Given predefined weights and thresholds, predict which of the indicators
   values are alarms.
}
\details{
Extracts the indices in \code{indicators} that correspond to an
   alarm according to the given weigths and thresholds. If \code{y} is
   given, the corresponding values of the response \emph{e.g.}
   over-mortality are also returned. In addition, episodes are formed
   by consecutive alarms (or by alarms occurring with time differences)
   lower or equal than \code{r}.
}
\examples{
  library(dlnm)
  data(chicagoNMMAPS)
  x <- chicagoNMMAPS$death
  dates <- as.POSIXlt(chicagoNMMAPS$date)
  n <- nrow(chicagoNMMAPS)

  # Compute over-mortality
  om <- excess(x, dates = dates, order = 15)
  
  # Extract all days for which om is above 40\%
  epis <- episodes(om, u = 40)

  # Prepare indicator based on temperature until lag 2
  indic <- matrix(NA, nrow = n, ncol = 3)
  indic[,1] <- chicagoNMMAPS$temp  # lag 0
  indic[,2] <- c(NA, chicagoNMMAPS$temp[-n]) # Lag 1
  indic[,3] <- c(NA, NA, chicagoNMMAPS$temp[1:(n-2)]) # lag 2

  # Evaluate different threshold/indicators based on these episodes
  tested <- find.threshold(indic, epis, u.grid = 20:35, thinning = "episodes",
     order.result = "Episodes_found")

  # Choose a result and predict
  final <- tested[1,]
  predict_alarms(indic, final[1:3], s = final[4], y = om)

}
\references{
Chebana F., Martel B., Gosselin P., Giroux J.X., Ouarda T.B.M.J., 2013. 
     A general and flexible methodology to define thresholds for heat health 
     watch and warning systems, applied to the province of Quebec (Canada). 
     International journal of biometeorology 57, 631-644.
}
