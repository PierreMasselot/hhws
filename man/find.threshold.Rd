% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find.threshold.R
\name{find.threshold}
\alias{find.threshold}
\title{Find thresholds}
\usage{
find.threshold(indicators, episodes, u.grid, fixed.alphas = NULL,
  alpha.step = 0.1, decreasing.alphas = TRUE, same.alphas = TRUE,
  order.result = NULL, order.decreasing = TRUE, keep.all = FALSE)
}
\arguments{
\item{indicators}{List of matrices containing the lagged covariates to 
construct weighted indicators. Can also be a matrix in the case of a
single indicator.}

\item{episodes}{A matrix or data.frame containing the indices of extreme
episodes. Must contain the time indices in the first column and the 
corresponding episode index in the second column as returned by  
\code{\link{episodes}}.}

\item{u.grid}{A list of vectors containing the grid of thresholds to be 
considered. The list must have the same number of elements than 
\code{indicators}.}

\item{fixed.alphas}{A list of optional prefixed weightings for a subset of
indicators. When provided, must have the same length as \code{indicators}
and contain \code{NULL} for each non-fixed indicator.}

\item{alpha.step}{Numeric value between 0 and .5. The step of the
sequence of weightings tested for the indicator.}

\item{decreasing.alphas}{Logical. If TRUE (the default), the alpha 
weightings are constrained to decrease with the lag.}

\item{same.alphas}{Logical. If TRUE, the weightings are constrained to be
identical for each indicator. Note that trying different weightings
(\code{same.alpha = FALSE}) can lead to significantly longer
computation time.}

\item{order.result}{Character of numeric value indicating a column used
to order the returned table.}

\item{order.decreasing}{Logical. If TRUE (the default), ordering of the
table is made by decreasing order to the column specified by
\code{order.result}.}

\item{keep.all}{Logical. If FALSE (the default), all combinations having 
both lower specificity and sensitivity than at least another combination
are discarded from the results. Otherwise, all tested combinations
are returned.}
}
\value{
A data.frame containing a subset (unless \code{keep.all = TRUE})  
   of weightings and thresholds. Weightings correspond to the columns
   with a name containing "alpha" and threshold to names beginning with "s_".
   In addition, several scores are given in each line:
   \itemize{
     \item{Detected}{The number of indices in \code{episodes} detected by
       the combination.}
     \item{Missed}{The number of indices in \code{episodes} missed by
       the combination.}
     \item{Sensitivity}{The proportion of indices in \code{episodes} detected by
       the combination, \emph{i.e.} Detected / n.}
     \item{False_alarms}{The number of false alarms, \emph{i.e.} of indices
       found by the combination which are not in \code{episodes}.}
     \item{Specificity}{The proportion of false alarms, \emph{i.e.} 
       False_alarms / n.}
     \item{Episodes_found}{The number of episodes found, which takes account
       of entire episodes instead of only indices.}
   }
}
\description{
Evaluate different combinations of threshold and indicator weightings
   according to their sensitivity and specificity.
}
\details{
We consider a warning system as a couple indicator/threshold
   used to launch alerts when forecasts of the indicator exceed the
   threshold. In the present function, the indicators considered are
   linear combinations of all matrix columns in the parameter 
   \code{indicators}, with the constraint that, for each indicator, the
   weights sum to 1.
   
   The indicator and threshold are determined by evaluating a large range
   of different weightings and threshold (given in \code{u.grid} and 
   \code{alpha.step}). For each combination of indicators/thresholds,
   the function computes the indices that consist in alerts in the data
   and compare them to the actual values given in \code{episodes}. The
   function then selects a set of best candidates (unless  
   \code{keep.all = TRUE}) based on sensitivity (the proportion of real
   episodes detected) and specificity (the proportion of false episode
   found). It is left to the user to choose the best combination by a 
   trade-off between specificity and sensitivity.
}
\examples{
   data(chicagoNMMAPS)
   x <- chicagoNMMAPS$death
   dates <- as.POSIXlt(chicagoNMMAPS$date)
   n <- nrow(chicagoNMMAPS)

   # Compute over-mortality
   om <- excess(x, dates = dates, order = 15)
  
   # Extract all days for which om is above 40\%
   epis <- episodes(om, u = 40)

   # Prepare indicator based on temperature until lag 2
   indic <- matrix(NA, nrow = n, ncol = 3)
   indic[,1] <- chicagoNMMAPS$temp  # lag 0
   indic[,2] <- c(NA, chicagoNMMAPS$temp[-n]) # Lag 1
   indic[,3] <- c(NA, NA, chicagoNMMAPS$temp[1:(n-2)]) # lag 2
   # Evaluate different threshold/indicators based on these episodes
   find.threshold(indic, epis, u.grid = 20:35)
}
\references{
Chebana F., Martel B., Gosselin P., Giroux J.X., Ouarda T.B.M.J., 2013. 
     A general and flexible methodology to define thresholds for heat health 
     watch and warning systems, applied to the province of Quebec (Canada). 
     International journal of biometeorology 57, 631-644.
   Pascal M., Laaidi K., Ledrans M., Baffert E., Caserio-Schonemann C.,
     Le Tertre A., Manach J., Medina S., Rudant J., Empereur-Bissonnet P.,
     2006. France's heat health watch warning system. International journal
     of biometeorology 50, 144-153.
}
\seealso{
[episodes()] for extracting episodes of extreme values.
}
